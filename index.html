<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<title>TESTING SVG</title>
	</head>
	<body>
	  	<div id="stage">
			<!-- Input SN. Search txt doc if SN is valid and what SVG files are associated with it  -->
			<label for="sn-input">SN:</label>
			<input type="text" id="sn-input" />
			<button onclick="isValidSn()">Search</button>
			
			<div id="result" class="menu">
				<p>THIS IS WHERE FILE LIST WILL APPEAR</p>
			</div>
			
			<!-- Display an initial SVG -->
			<object id= "svgObj" type="image/svg+xml">THIS IS WHERE THE SVG WILL APPEAR</object>

			<!-- output for the 'ordering' table' -->
			<div id="tableOut"></div>
			<button onclick="table_to_cart()">Add items to cart</button>

			<div id="cart"><p>THIS IS WHERE THE CART WILL APPEAR</p></div>
	  	</div>

		<!------------------------------------------------ SCRIPTS ------------------------------------------------>

		<!-- script for checking JSON file and providing links to each part -->
		<script>
			async function isValidSn() 
			{
	      		const enteredSn = document.getElementById("sn-input").value.trim();
	      		const resultDiv = document.getElementById("result");
	
			  	try 
				{
			        // Load the JSON file
			        const response = await fetch("sn_docs.json");
			        const data = await response.json();
			
			        // Function to build links
			        const buildLinks = (files) => 
			          files.map(file => `<a href="${file}" target="_blank">${file}</a>`).join("<br>");

					// Look for a system with a matching SN
    				const match = data.systems.find(system => system.sn === enteredSn);
					if (match) {
					  resultDiv.innerHTML = "<strong>Files:</strong><br>" + buildLinks(match.files);
					} else {
					  resultDiv.innerHTML = "No files found for SN: " + enteredSn;
					}
			      } catch (error) {
				        console.error("Error loading JSON:", error);
				        resultDiv.innerHTML = "Error reading JSON file.";
      				} 
			}
		</script>
		
		
<script>
  const obj = document.getElementById('svgObj');
  const out = document.getElementById('tableOut');

  // Click a result link → load SVG into the <object> instead of opening a new tab
  document.querySelector('.menu').addEventListener('click', (e) => {
    const a = e.target.closest('a');
    if (!a) return;
    e.preventDefault();
    obj.data = a.getAttribute('href');
  });

  // --- Util: escape HTML ---
  function escapeHtml(s) {
    return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  // --- Your existing hotspot collector (kept as-is) ---
  function collectFileHotspots(svgRoot) {
    const fileMap = {};
    svgRoot.querySelectorAll('a').forEach(a => {
      const href = a.getAttributeNS("http://www.w3.org/1999/xlink", "href") || a.getAttribute("href");
      if (!href) return;
      const filename = href.split(/[/\\]/).pop();
      const g = a.closest('g[id^="hotspot."]');
      if (!g) return;
      const hotspotId = g.getAttribute('id'); // e.g. "hotspot.8"
      (fileMap[filename] ||= []).push(hotspotId);
    });
    return fileMap;
  }

  // --- NEW: extract rows + attach hotspot ids per row ---
  function extractRowsWithHotspots(svgDoc, fileMap) {
    // 1) Get Line* groups in numeric order
    let groups = [...svgDoc.querySelectorAll('g[id^="Line"]')];
    groups.sort((a, b) => (parseInt(a.id.match(/\d+/)) || 0) - (parseInt(b.id.match(/\d+/)) || 0));

    // 2) For each line group:
    //    - cells: all <text> in document order
    //    - filenames: any <a> inside the line (href filename)
    //    - hotspots: union of fileMap[filename]
    return groups.map(g => {
      const cells = [...g.querySelectorAll('text')].map(t => t.textContent.trim());

      const filenames = [...g.querySelectorAll('a')].map(a => {
        const href = a.getAttributeNS("http://www.w3.org/1999/xlink", "href") || a.getAttribute("href");
        return href ? href.split(/[/\\]/).pop() : null;
      }).filter(Boolean);

      const hs = new Set();
      filenames.forEach(fn => (fileMap[fn] || []).forEach(id => hs.add(id)));

      return { cells, hotspots: [...hs] };
    });
  }

  // --- Inject a CSS class in the SVG so we can green-tint hotspots when hovered from HTML ---
  function ensureSvgHighlightStyle(svgDoc) {
    const svg = svgDoc.querySelector('svg');
    if (!svg) return;
    if (svgDoc.getElementById('htmlHoverStyle')) return;

    const style = svgDoc.createElementNS('http://www.w3.org/2000/svg', 'style');
    style.setAttribute('id', 'htmlHoverStyle');
    // Apply to the whole hotspot group subtree
    style.textContent = `
      .html-hl * {
        fill: #1aa34a !important;
        stroke: #1aa34a !important;
        opacity: 0.6 !important;
      }
    `;
    svg.appendChild(style);
  }

  // --- Turn a list of hotspot ids on/off inside the SVG ---
  function setSvgHotspots(svgDoc, ids, on) {
    ids.forEach(id => {
      const g = svgDoc.getElementById(id);
      if (g) g.classList.toggle('html-hl', on);
    });
  }

  // --- From a hotspot id, find and toggle matching HTML rows ---
  function setHtmlRowsForHotspot(hotspotId, on) {
    document.querySelectorAll(`#tableOut tbody tr[data-hotspots]`).forEach(tr => {
      const ids = tr.dataset.hotspots.split(',');
      if (ids.includes(hotspotId)) {
        tr.classList.toggle('row-hl', on);
      }
    });
  }

  // --- Build the HTML table and wire all the hover handlers ---
  function renderTable(rowsWithHs, svgDoc) {
    if (!rowsWithHs.length) {
      out.textContent = 'No Line* groups with <text> found.';
      return;
    }

    // HTML
    let html = '<table><thead><tr>' +
      '<th>ITEM NO.</th><th>PART NUMBER</th><th>DESCRIPTION</th><th>QTY</th><th>ORDER QTY</th>' +
      '</tr></thead><tbody>';

    rowsWithHs.forEach(({ cells, hotspots }) => {
      const tds = cells.map(c => `<td>${escapeHtml(c)}</td>`).join('');
      html += `<tr data-hotspots="${hotspots.join(',')}">${tds}<td><input type="number" step="1" min="0"/></td></tr>`;
    });

    html += '</tbody></table>';
    out.innerHTML = html;

    // HTML → SVG hover
    out.querySelectorAll('tbody tr').forEach(tr => {
      const ids = (tr.dataset.hotspots || '').split(',').filter(Boolean);
      if (!ids.length) return;

      tr.addEventListener('mouseenter', () => {
        tr.classList.add('row-hl');
        setSvgHotspots(svgDoc, ids, true);
      });
      tr.addEventListener('mouseleave', () => {
        tr.classList.remove('row-hl');
        setSvgHotspots(svgDoc, ids, false);
      });
    });

    // SVG → HTML hover (mirror)
    svgDoc.querySelectorAll('g[id^="hotspot."]').forEach(g => {
      const id = g.id;
      g.addEventListener('mouseenter', () => setHtmlRowsForHotspot(id, true));
      g.addEventListener('mouseleave', () => setHtmlRowsForHotspot(id, false));
    });
  }

  // --- Main: when the SVG loads, wire everything up ---
  obj.addEventListener('load', () => {
    const svgDoc = obj.contentDocument || obj.getSVGDocument?.();
    if (!svgDoc || svgDoc.documentElement?.tagName.toLowerCase() !== 'svg') return;

    ensureSvgHighlightStyle(svgDoc);

    const svgRoot = svgDoc.querySelector('svg');
    const fileMap = collectFileHotspots(svgRoot); // { filename: [ 'hotspot.8', ... ] }

    // Build table rows alongside their hotspot ids
    const rowsWithHs = extractRowsWithHotspots(svgDoc, fileMap);

    // Finally, render the HTML table and wire hover both ways
    renderTable(rowsWithHs, svgDoc);
  });
</script>



		

		<!-- script to produce a cart which takes the items from the filled out form and saves them into local storage for persistency -->
		<script>
			let cart = JSON.parse(localStorage.getItem('cart')) || [];
			
			function saveCart() {
			  	localStorage.setItem('cart', JSON.stringify(cart));
			}
			
			function renderCart() {
				if (!cart.length) {
					document.getElementById('cart').innerHTML = "<p>Cart is empty.</p>";
					return;
				}
				let html = '<h3>Shopping Cart</h3><table id="cartTable"><tr><th>Part Number</th><th>Description</th><th>Qty</th></tr>';
				for (const item of cart) {
					html += `<tr><td>${item.part}</td><td>${item.desc}</td><td>${item.qty}</td></tr>`;
				}
				html += '</table>';
				document.getElementById('cart').innerHTML = html;
			}
			
			// Called when user clicks "Add to Cart"
			function table_to_cart() {
				// Look for table rows in #tableOut
				const rows = document.querySelectorAll('#tableOut table tbody tr');
				rows.forEach(tr => {
					const cells = tr.querySelectorAll('td');
					const qtyInput = tr.querySelector('input');
					if (!qtyInput) return;
					const qty = parseInt(qtyInput.value, 10);
					if (qty > 0) {
						const item = {
							part: cells[1].textContent,   // 2nd column = Part Number
							desc: cells[2].textContent,   // 3rd column = Description
							qty
						};
						// If already in cart, update qty
						const existing = cart.find(i => i.part === item.part);
						if (existing) {
							existing.qty += qty;
						} else {
							cart.push(item);
						}
					}
				});
				saveCart();
				renderCart();
			}

			// extract the rows from the cart for odoo to be able to access the cart data
			function readCartFromTable() {
				const table = document.getElementById("cartTable");
				if (!table) return [];
				const rows = [];
				table.querySelectorAll("tbody tr").forEach(tr => {
					const tds = tr.querySelectorAll("td");
					if (tds.length >= 3) {
						const qtyInput = tds[2].querySelector("input");
						const qtyText = qtyInput ? qtyInput.value : tds[2].textContent;
						rows.push({
							part: tds[0].textContent.trim(),
							description: tds[1].textContent.trim(),
							qty: parseInt(qtyText.trim(), 10) || 0
						});
					}
				});
			  return rows;
			}
			
			// Listen for parent requests
			window.addEventListener("message", e => {
				if (e.data && e.data.type === "REQUEST_CART_ROWS") {
					const rows = readCartFromTable();
					e.source.postMessage({ type: "CART_ROWS", rows }, e.origin);
			  	}
			});
	  </script>
	</body>
</html>












